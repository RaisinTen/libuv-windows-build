
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>uv_handle_t — Base handle &#8212; libuv documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.40.1-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="uv_req_t — Base request" href="request.html" />
    <link rel="prev" title="uv_loop_t — Event loop" href="loop.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="request.html" title="uv_req_t — Base request"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="loop.html" title="uv_loop_t — Event loop"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">libuv 1.40.1-dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="api.html" accesskey="U">API documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="uv-handle-t-base-handle">
<span id="handle"></span><h1><a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal"><span class="pre">uv_handle_t</span></code></a> — Base handle<a class="headerlink" href="#uv-handle-t-base-handle" title="Permalink to this headline">¶</a></h1>
<p><cite>uv_handle_t</cite> is the base type for all libuv handle types.</p>
<p>Structures are aligned so that any libuv handle can be cast to <cite>uv_handle_t</cite>.
All API functions defined here work with any handle type.</p>
<p>Libuv handles are not movable. Pointers to handle structures passed to
functions must remain valid for the duration of the requested operation. Take
care when using stack allocated handles.</p>
<div class="section" id="data-types">
<h2>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.uv_handle_t">
<code class="descname">uv_handle_t</code><a class="headerlink" href="#c.uv_handle_t" title="Permalink to this definition">¶</a></dt>
<dd><p>The base libuv handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_any_handle">
<code class="descname">uv_any_handle</code><a class="headerlink" href="#c.uv_any_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Union of all handle types.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_alloc_cb">
void <code class="descname">(*uv_alloc_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em>, size_t<em>&nbsp;suggested_size</em>, <a class="reference internal" href="misc.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a>*<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_alloc_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed to <a class="reference internal" href="stream.html#c.uv_read_start" title="uv_read_start"><code class="xref c c-func docutils literal"><span class="pre">uv_read_start()</span></code></a> and
<a class="reference internal" href="udp.html#c.uv_udp_recv_start" title="uv_udp_recv_start"><code class="xref c c-func docutils literal"><span class="pre">uv_udp_recv_start()</span></code></a>. The user must allocate memory and fill the supplied
<a class="reference internal" href="misc.html#c.uv_buf_t" title="uv_buf_t"><code class="xref c c-type docutils literal"><span class="pre">uv_buf_t</span></code></a> structure. If NULL is assigned as the buffer’s base or 0 as its length,
a <code class="docutils literal"><span class="pre">UV_ENOBUFS</span></code> error will be triggered in the <a class="reference internal" href="udp.html#c.uv_udp_recv_cb" title="uv_udp_recv_cb"><code class="xref c c-type docutils literal"><span class="pre">uv_udp_recv_cb</span></code></a> or the
<a class="reference internal" href="stream.html#c.uv_read_cb" title="uv_read_cb"><code class="xref c c-type docutils literal"><span class="pre">uv_read_cb</span></code></a> callback.</p>
<p>Each buffer is used only once and the user is responsible for freeing it in the
<a class="reference internal" href="udp.html#c.uv_udp_recv_cb" title="uv_udp_recv_cb"><code class="xref c c-type docutils literal"><span class="pre">uv_udp_recv_cb</span></code></a> or the <a class="reference internal" href="stream.html#c.uv_read_cb" title="uv_read_cb"><code class="xref c c-type docutils literal"><span class="pre">uv_read_cb</span></code></a> callback.</p>
<p>A suggested size (65536 at the moment in most cases) is provided, but it’s just an indication,
not related in any way to the pending data to be read. The user is free to allocate the amount
of memory they decide.</p>
<p>As an example, applications with custom allocation schemes such as using freelists, allocation
pools or slab based allocators may decide to use a different size which matches the memory
chunks they already have.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="n">my_alloc_cb</span><span class="p">(</span><span class="n">uv_handle_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">suggested_size</span><span class="p">,</span> <span class="n">uv_buf_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">suggested_size</span><span class="p">);</span>
  <span class="n">buf</span><span class="o">-&gt;</span><span class="nb">len</span> <span class="o">=</span> <span class="n">suggested_size</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_close_cb">
void <code class="descname">(*uv_close_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_close_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed to <a class="reference internal" href="#c.uv_close" title="uv_close"><code class="xref c c-func docutils literal"><span class="pre">uv_close()</span></code></a>.</p>
</dd></dl>

<div class="section" id="public-members">
<h3>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h3>
<dl class="member">
<dt id="c.uv_handle_t.loop">
<a class="reference internal" href="loop.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>* <code class="descname">uv_handle_t.loop</code><a class="headerlink" href="#c.uv_handle_t.loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer to the <a class="reference internal" href="loop.html#c.uv_loop_t" title="uv_loop_t"><code class="xref c c-type docutils literal"><span class="pre">uv_loop_t</span></code></a> the handle is running on. Readonly.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_handle_t.type">
uv_handle_type <code class="descname">uv_handle_t.type</code><a class="headerlink" href="#c.uv_handle_t.type" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="xref c c-type docutils literal"><span class="pre">uv_handle_type</span></code>, indicating the type of the underlying handle. Readonly.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_handle_t.data">
void* <code class="descname">uv_handle_t.data</code><a class="headerlink" href="#c.uv_handle_t.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Space for user-defined arbitrary data. libuv does not use this field.</p>
</dd></dl>

</div>
</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<dl class="macro">
<dt id="c.UV_HANDLE_TYPE_MAP">
<code class="descname">UV_HANDLE_TYPE_MAP</code><span class="sig-paren">(</span>iter_macro<span class="sig-paren">)</span><a class="headerlink" href="#c.UV_HANDLE_TYPE_MAP" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that expands to a series of invocations of <cite>iter_macro</cite> for
each of the handle types. <cite>iter_macro</cite> is invoked with two
arguments: the name of the <cite>uv_handle_type</cite> element without the
<cite>UV_</cite> prefix, and the name of the corresponding structure type
without the <cite>uv_</cite> prefix and <cite>_t</cite> suffix.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_is_active">
int <code class="descname">uv_is_active</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_is_active" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns non-zero if the handle is active, zero if it’s inactive. What
“active” means depends on the type of handle:</p>
<ul class="simple">
<li>A uv_async_t handle is always active and cannot be deactivated, except
by closing it with uv_close().</li>
<li>A uv_pipe_t, uv_tcp_t, uv_udp_t, etc. handle - basically any handle that
deals with i/o - is active when it is doing something that involves i/o,
like reading, writing, connecting, accepting new connections, etc.</li>
<li>A uv_check_t, uv_idle_t, uv_timer_t, etc. handle is active when it has
been started with a call to uv_check_start(), uv_idle_start(), etc.</li>
</ul>
<p>Rule of thumb: if a handle of type <cite>uv_foo_t</cite> has a <cite>uv_foo_start()</cite>
function, then it’s active from the moment that function is called.
Likewise, <cite>uv_foo_stop()</cite> deactivates the handle again.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_is_closing">
int <code class="descname">uv_is_closing</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_is_closing" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns non-zero if the handle is closing or closed, zero otherwise.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function should only be used between the initialization of the handle and the
arrival of the close callback.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_close">
void <code class="descname">uv_close</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="#c.uv_close_cb" title="uv_close_cb">uv_close_cb</a><em>&nbsp;close_cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Request handle to be closed. <cite>close_cb</cite> will be called asynchronously after
this call. This MUST be called on each handle before memory is released.
Moreover, the memory can only be released in <cite>close_cb</cite> or after it has
returned.</p>
<p>Handles that wrap file descriptors are closed immediately but
<cite>close_cb</cite> will still be deferred to the next iteration of the event loop.
It gives you a chance to free up any resources associated with the handle.</p>
<p>In-progress requests, like uv_connect_t or uv_write_t, are cancelled and
have their callbacks called asynchronously with status=UV_ECANCELED.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_ref">
void <code class="descname">uv_ref</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Reference the given handle. References are idempotent, that is, if a handle
is already referenced calling this function again will have no effect.</p>
<p>See <a class="reference internal" href="#refcount"><span class="std std-ref">Reference counting</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_unref">
void <code class="descname">uv_unref</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-reference the given handle. References are idempotent, that is, if a handle
is not referenced calling this function again will have no effect.</p>
<p>See <a class="reference internal" href="#refcount"><span class="std std-ref">Reference counting</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_has_ref">
int <code class="descname">uv_has_ref</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_has_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns non-zero if the handle referenced, zero otherwise.</p>
<p>See <a class="reference internal" href="#refcount"><span class="std std-ref">Reference counting</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_handle_size">
size_t <code class="descname">uv_handle_size</code><span class="sig-paren">(</span>uv_handle_type<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_handle_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of the given handle type. Useful for FFI binding writers
who don’t want to know the structure layout.</p>
</dd></dl>

</div>
<div class="section" id="miscellaneous-api-functions">
<h2>Miscellaneous API functions<a class="headerlink" href="#miscellaneous-api-functions" title="Permalink to this headline">¶</a></h2>
<p>The following API functions take a <a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal"><span class="pre">uv_handle_t</span></code></a> argument but they work
just for some handle types.</p>
<dl class="function">
<dt id="c.uv_send_buffer_size">
int <code class="descname">uv_send_buffer_size</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em>, int*<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_send_buffer_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets or sets the size of the send buffer that the operating
system uses for the socket.</p>
<p>If <cite>*value</cite> == 0, then it will set <cite>*value</cite> to the current send buffer size.
If <cite>*value</cite> &gt; 0 then it will use <cite>*value</cite> to set the new send buffer size.</p>
<p>On success, zero is returned. On error, a negative result is
returned.</p>
<p>This function works for TCP, pipe and UDP handles on Unix and for TCP and
UDP handles on Windows.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Linux will set double the size and return double the size of the original set value.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_recv_buffer_size">
int <code class="descname">uv_recv_buffer_size</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em>, int*<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_recv_buffer_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets or sets the size of the receive buffer that the operating
system uses for the socket.</p>
<p>If <cite>*value</cite> == 0, then it will set <cite>*value</cite> to the current receive buffer size.
If <cite>*value</cite> &gt; 0 then it will use <cite>*value</cite> to set the new receive buffer size.</p>
<p>On success, zero is returned. On error, a negative result is
returned.</p>
<p>This function works for TCP, pipe and UDP handles on Unix and for TCP and
UDP handles on Windows.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Linux will set double the size and return double the size of the original set value.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fileno">
int <code class="descname">uv_fileno</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="misc.html#c.uv_os_fd_t" title="uv_os_fd_t">uv_os_fd_t</a>*<em>&nbsp;fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fileno" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the platform dependent file descriptor equivalent.</p>
<p>The following handles are supported: TCP, pipes, TTY, UDP and poll. Passing
any other handle type will fail with <cite>UV_EINVAL</cite>.</p>
<p>If a handle doesn’t have an attached file descriptor yet or the handle
itself has been closed, this function will return <cite>UV_EBADF</cite>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Be very careful when using this function. libuv assumes it’s in control of the file
descriptor so any change to it may lead to malfunction.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_handle_get_loop">
<a class="reference internal" href="loop.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>* <code class="descname">uv_handle_get_loop</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_handle_get_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>handle-&gt;loop</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_handle_get_data">
void* <code class="descname">uv_handle_get_data</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_handle_get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>handle-&gt;data</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_handle_set_data">
void* <code class="descname">uv_handle_set_data</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em>, void*<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_handle_set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <cite>handle-&gt;data</cite> to <cite>data</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_handle_get_type">
uv_handle_type <code class="descname">uv_handle_get_type</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_handle_get_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>handle-&gt;type</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_handle_type_name">
const char* <code class="descname">uv_handle_type_name</code><span class="sig-paren">(</span>uv_handle_type<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_handle_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name for the equivalent struct for a given handle type,
e.g. <cite>“pipe”</cite> (as in <a class="reference internal" href="pipe.html#c.uv_pipe_t" title="uv_pipe_t"><code class="xref c c-type docutils literal"><span class="pre">uv_pipe_t</span></code></a>) for <cite>UV_NAMED_PIPE</cite>.</p>
<p>If no such handle type exists, this returns <cite>NULL</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="reference-counting">
<span id="refcount"></span><h2>Reference counting<a class="headerlink" href="#reference-counting" title="Permalink to this headline">¶</a></h2>
<p>The libuv event loop (if run in the default mode) will run until there are no
active <cite>and</cite> referenced handles left. The user can force the loop to exit early
by unreferencing handles which are active, for example by calling <a class="reference internal" href="#c.uv_unref" title="uv_unref"><code class="xref c c-func docutils literal"><span class="pre">uv_unref()</span></code></a>
after calling <a class="reference internal" href="timer.html#c.uv_timer_start" title="uv_timer_start"><code class="xref c c-func docutils literal"><span class="pre">uv_timer_start()</span></code></a>.</p>
<p>A handle can be referenced or unreferenced, the refcounting scheme doesn’t use
a counter, so both operations are idempotent.</p>
<p>All handles are referenced when active by default, see <a class="reference internal" href="#c.uv_is_active" title="uv_is_active"><code class="xref c c-func docutils literal"><span class="pre">uv_is_active()</span></code></a>
for a more detailed explanation on what being <cite>active</cite> involves.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">uv_handle_t</span></code> — Base handle</a><ul>
<li><a class="reference internal" href="#data-types">Data types</a><ul>
<li><a class="reference internal" href="#public-members">Public members</a></li>
</ul>
</li>
<li><a class="reference internal" href="#api">API</a></li>
<li><a class="reference internal" href="#miscellaneous-api-functions">Miscellaneous API functions</a></li>
<li><a class="reference internal" href="#reference-counting">Reference counting</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="loop.html"
                        title="previous chapter"><code class="docutils literal"><span class="pre">uv_loop_t</span></code> — Event loop</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="request.html"
                        title="next chapter"><code class="docutils literal"><span class="pre">uv_req_t</span></code> — Base request</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/handle.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="request.html" title="uv_req_t — Base request"
             >next</a> |</li>
        <li class="right" >
          <a href="loop.html" title="uv_loop_t — Event loop"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">libuv 1.40.1-dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="api.html" >API documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-present, libuv contributors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7.
    </div>
  </body>
</html>
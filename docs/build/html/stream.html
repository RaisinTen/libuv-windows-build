
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>uv_stream_t — Stream handle &#8212; libuv documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.40.1-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="uv_tcp_t — TCP handle" href="tcp.html" />
    <link rel="prev" title="uv_process_t — Process handle" href="process.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tcp.html" title="uv_tcp_t — TCP handle"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="process.html" title="uv_process_t — Process handle"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">libuv 1.40.1-dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="api.html" accesskey="U">API documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="uv-stream-t-stream-handle">
<span id="stream"></span><h1><a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal"><span class="pre">uv_stream_t</span></code></a> — Stream handle<a class="headerlink" href="#uv-stream-t-stream-handle" title="Permalink to this headline">¶</a></h1>
<p>Stream handles provide an abstraction of a duplex communication channel.
<a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal"><span class="pre">uv_stream_t</span></code></a> is an abstract type, libuv provides 3 stream implementations
in the form of <a class="reference internal" href="tcp.html#c.uv_tcp_t" title="uv_tcp_t"><code class="xref c c-type docutils literal"><span class="pre">uv_tcp_t</span></code></a>, <a class="reference internal" href="pipe.html#c.uv_pipe_t" title="uv_pipe_t"><code class="xref c c-type docutils literal"><span class="pre">uv_pipe_t</span></code></a> and <a class="reference internal" href="tty.html#c.uv_tty_t" title="uv_tty_t"><code class="xref c c-type docutils literal"><span class="pre">uv_tty_t</span></code></a>.</p>
<div class="section" id="data-types">
<h2>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.uv_stream_t">
<code class="descname">uv_stream_t</code><a class="headerlink" href="#c.uv_stream_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Stream handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_connect_t">
<code class="descname">uv_connect_t</code><a class="headerlink" href="#c.uv_connect_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect request type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_shutdown_t">
<code class="descname">uv_shutdown_t</code><a class="headerlink" href="#c.uv_shutdown_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown request type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_write_t">
<code class="descname">uv_write_t</code><a class="headerlink" href="#c.uv_write_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Write request type. Careful attention must be paid when reusing objects of
this type. When a stream is in non-blocking mode, write requests sent
with <code class="docutils literal"><span class="pre">uv_write</span></code> will be queued. Reusing objects at this point is undefined
behaviour. It is safe to reuse the <code class="docutils literal"><span class="pre">uv_write_t</span></code> object only after the
callback passed to <code class="docutils literal"><span class="pre">uv_write</span></code> is fired.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_read_cb">
void <code class="descname">(*uv_read_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;stream</em>, ssize_t<em>&nbsp;nread</em>, const <a class="reference internal" href="misc.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a>*<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_read_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback called when data was read on a stream.</p>
<p><cite>nread</cite> is &gt; 0 if there is data available or &lt; 0 on error. When we’ve
reached EOF, <cite>nread</cite> will be set to <code class="docutils literal"><span class="pre">UV_EOF</span></code>. When <cite>nread</cite> &lt; 0,
the <cite>buf</cite> parameter might not point to a valid buffer; in that case
<cite>buf.len</cite> and <cite>buf.base</cite> are both set to 0.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>nread</cite> might be 0, which does <em>not</em> indicate an error or EOF. This
is equivalent to <code class="docutils literal"><span class="pre">EAGAIN</span></code> or <code class="docutils literal"><span class="pre">EWOULDBLOCK</span></code> under <code class="docutils literal"><span class="pre">read(2)</span></code>.</p>
</div>
<p>The callee is responsible for stopping/closing the stream when an error happens
by calling <a class="reference internal" href="#c.uv_read_stop" title="uv_read_stop"><code class="xref c c-func docutils literal"><span class="pre">uv_read_stop()</span></code></a> or <a class="reference internal" href="handle.html#c.uv_close" title="uv_close"><code class="xref c c-func docutils literal"><span class="pre">uv_close()</span></code></a>. Trying to read
from the stream again is undefined.</p>
<p>The callee is responsible for freeing the buffer, libuv does not reuse it.
The buffer may be a null buffer (where <cite>buf-&gt;base</cite> == NULL and <cite>buf-&gt;len</cite> == 0)
on error.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_write_cb">
void <code class="descname">(*uv_write_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_write_t" title="uv_write_t">uv_write_t</a>*<em>&nbsp;req</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_write_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback called after data was written on a stream. <cite>status</cite> will be 0 in
case of success, &lt; 0 otherwise.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_connect_cb">
void <code class="descname">(*uv_connect_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_connect_t" title="uv_connect_t">uv_connect_t</a>*<em>&nbsp;req</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_connect_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback called after a connection started by <code class="xref c c-func docutils literal"><span class="pre">uv_connect()</span></code> is done.
<cite>status</cite> will be 0 in case of success, &lt; 0 otherwise.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_shutdown_cb">
void <code class="descname">(*uv_shutdown_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_shutdown_t" title="uv_shutdown_t">uv_shutdown_t</a>*<em>&nbsp;req</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_shutdown_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback called after a shutdown request has been completed. <cite>status</cite> will
be 0 in case of success, &lt; 0 otherwise.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_connection_cb">
void <code class="descname">(*uv_connection_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;server</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_connection_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback called when a stream server has received an incoming connection.
The user can accept the connection by calling <a class="reference internal" href="#c.uv_accept" title="uv_accept"><code class="xref c c-func docutils literal"><span class="pre">uv_accept()</span></code></a>.
<cite>status</cite> will be 0 in case of success, &lt; 0 otherwise.</p>
</dd></dl>

<div class="section" id="public-members">
<h3>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h3>
<dl class="member">
<dt id="c.uv_stream_t.write_queue_size">
size_t <code class="descname">uv_stream_t.write_queue_size</code><a class="headerlink" href="#c.uv_stream_t.write_queue_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the amount of queued bytes waiting to be sent. Readonly.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_connect_t.handle">
<a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>* <code class="descname">uv_connect_t.handle</code><a class="headerlink" href="#c.uv_connect_t.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer to the stream where this connection request is running.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_shutdown_t.handle">
<a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>* <code class="descname">uv_shutdown_t.handle</code><a class="headerlink" href="#c.uv_shutdown_t.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer to the stream where this shutdown request is running.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_write_t.handle">
<a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>* <code class="descname">uv_write_t.handle</code><a class="headerlink" href="#c.uv_write_t.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer to the stream where this write request is running.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_write_t.send_handle">
<a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>* <code class="descname">uv_write_t.send_handle</code><a class="headerlink" href="#c.uv_write_t.send_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer to the stream being sent using this write request.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="handle.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal"><span class="pre">uv_handle_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.uv_shutdown">
int <code class="descname">uv_shutdown</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_shutdown_t" title="uv_shutdown_t">uv_shutdown_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="#c.uv_shutdown_cb" title="uv_shutdown_cb">uv_shutdown_cb</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown the outgoing (write) side of a duplex stream. It waits for pending
write requests to complete. The <cite>handle</cite> should refer to a initialized stream.
<cite>req</cite> should be an uninitialized shutdown request struct. The <cite>cb</cite> is called
after shutdown is complete.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_listen">
int <code class="descname">uv_listen</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;stream</em>, int<em>&nbsp;backlog</em>, <a class="reference internal" href="#c.uv_connection_cb" title="uv_connection_cb">uv_connection_cb</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_listen" title="Permalink to this definition">¶</a></dt>
<dd><p>Start listening for incoming connections. <cite>backlog</cite> indicates the number of
connections the kernel might queue, same as <a class="reference external" href="https://man7.org/linux/man-pages/man2/listen.2.html">listen(2)</a>. When a new
incoming connection is received the <a class="reference internal" href="#c.uv_connection_cb" title="uv_connection_cb"><code class="xref c c-type docutils literal"><span class="pre">uv_connection_cb</span></code></a> callback is
called.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_accept">
int <code class="descname">uv_accept</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;server</em>, <a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_accept" title="Permalink to this definition">¶</a></dt>
<dd><p>This call is used in conjunction with <a class="reference internal" href="#c.uv_listen" title="uv_listen"><code class="xref c c-func docutils literal"><span class="pre">uv_listen()</span></code></a> to accept incoming
connections. Call this function after receiving a <a class="reference internal" href="#c.uv_connection_cb" title="uv_connection_cb"><code class="xref c c-type docutils literal"><span class="pre">uv_connection_cb</span></code></a>
to accept the connection. Before calling this function the client handle must
be initialized. &lt; 0 return value indicates an error.</p>
<p>When the <a class="reference internal" href="#c.uv_connection_cb" title="uv_connection_cb"><code class="xref c c-type docutils literal"><span class="pre">uv_connection_cb</span></code></a> callback is called it is guaranteed that
this function will complete successfully the first time. If you attempt to use
it more than once, it may fail. It is suggested to only call this function once
per <a class="reference internal" href="#c.uv_connection_cb" title="uv_connection_cb"><code class="xref c c-type docutils literal"><span class="pre">uv_connection_cb</span></code></a> call.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>server</cite> and <cite>client</cite> must be handles running on the same loop.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_read_start">
int <code class="descname">uv_read_start</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;stream</em>, <a class="reference internal" href="handle.html#c.uv_alloc_cb" title="uv_alloc_cb">uv_alloc_cb</a><em>&nbsp;alloc_cb</em>, <a class="reference internal" href="#c.uv_read_cb" title="uv_read_cb">uv_read_cb</a><em>&nbsp;read_cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_read_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Read data from an incoming stream. The <a class="reference internal" href="#c.uv_read_cb" title="uv_read_cb"><code class="xref c c-type docutils literal"><span class="pre">uv_read_cb</span></code></a> callback will
be made several times until there is no more data to read or
<a class="reference internal" href="#c.uv_read_stop" title="uv_read_stop"><code class="xref c c-func docutils literal"><span class="pre">uv_read_stop()</span></code></a> is called.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.38.0: </span><a class="reference internal" href="#c.uv_read_start" title="uv_read_start"><code class="xref c c-func docutils literal"><span class="pre">uv_read_start()</span></code></a> now consistently
returns <cite>UV_EALREADY</cite> when called twice, and <cite>UV_EINVAL</cite> when the
stream is closing. With older libuv versions, it returns <cite>UV_EALREADY</cite>
on Windows but not UNIX, and <cite>UV_EINVAL</cite> on UNIX but not Windows.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_read_stop">
int <code class="descname">uv_read_stop</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_read_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop reading data from the stream. The <a class="reference internal" href="#c.uv_read_cb" title="uv_read_cb"><code class="xref c c-type docutils literal"><span class="pre">uv_read_cb</span></code></a> callback will
no longer be called.</p>
<p>This function is idempotent and may be safely called on a stopped stream.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_write">
int <code class="descname">uv_write</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_write_t" title="uv_write_t">uv_write_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;handle</em>, const <a class="reference internal" href="misc.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a><em>&nbsp;bufs[]</em>, unsigned int<em>&nbsp;nbufs</em>, <a class="reference internal" href="#c.uv_write_cb" title="uv_write_cb">uv_write_cb</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to stream. Buffers are written in order. Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">cb</span><span class="p">(</span><span class="n">uv_write_t</span><span class="o">*</span> <span class="n">req</span><span class="p">,</span> <span class="nb">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">/*</span> <span class="n">Logic</span> <span class="n">which</span> <span class="n">handles</span> <span class="n">the</span> <span class="n">write</span> <span class="n">result</span> <span class="o">*/</span>
<span class="p">}</span>

<span class="n">uv_buf_t</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">uv_buf_t</span> <span class="n">b</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">uv_write_t</span> <span class="n">req1</span><span class="p">;</span>
<span class="n">uv_write_t</span> <span class="n">req2</span><span class="p">;</span>

<span class="o">/*</span> <span class="n">writes</span> <span class="s2">&quot;1234&quot;</span> <span class="o">*/</span>
<span class="n">uv_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req1</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
<span class="n">uv_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req2</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The memory pointed to by the buffers must remain valid until the callback gets called.
This also holds for <a class="reference internal" href="#c.uv_write2" title="uv_write2"><code class="xref c c-func docutils literal"><span class="pre">uv_write2()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_write2">
int <code class="descname">uv_write2</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_write_t" title="uv_write_t">uv_write_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;handle</em>, const <a class="reference internal" href="misc.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a><em>&nbsp;bufs[]</em>, unsigned int<em>&nbsp;nbufs</em>, <a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;send_handle</em>, <a class="reference internal" href="#c.uv_write_cb" title="uv_write_cb">uv_write_cb</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_write2" title="Permalink to this definition">¶</a></dt>
<dd><p>Extended write function for sending handles over a pipe. The pipe must be
initialized with <cite>ipc</cite> == 1.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>send_handle</cite> must be a TCP socket or pipe, which is a server or a connection (listening
or connected state). Bound sockets or pipes will be assumed to be servers.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_try_write">
int <code class="descname">uv_try_write</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;handle</em>, const <a class="reference internal" href="misc.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a><em>&nbsp;bufs[]</em>, unsigned int<em>&nbsp;nbufs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_try_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#c.uv_write" title="uv_write"><code class="xref c c-func docutils literal"><span class="pre">uv_write()</span></code></a>, but won’t queue a write request if it can’t be
completed immediately.</p>
<p>Will return either:</p>
<ul class="simple">
<li>&gt; 0: number of bytes written (can be less than the supplied buffer size).</li>
<li>&lt; 0: negative error code (<code class="docutils literal"><span class="pre">UV_EAGAIN</span></code> is returned if no data can be sent
immediately).</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="c.uv_is_readable">
int <code class="descname">uv_is_readable</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_is_readable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if the stream is readable, 0 otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_is_writable">
int <code class="descname">uv_is_writable</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_is_writable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if the stream is writable, 0 otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_stream_set_blocking">
int <code class="descname">uv_stream_set_blocking</code><span class="sig-paren">(</span><a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;blocking</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_stream_set_blocking" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable blocking mode for a stream.</p>
<p>When blocking mode is enabled all writes complete synchronously. The
interface remains unchanged otherwise, e.g. completion or failure of the
operation will still be reported through a callback which is made
asynchronously.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Relying too much on this API is not recommended. It is likely to change
significantly in the future.</p>
<p>Currently only works on Windows for <a class="reference internal" href="pipe.html#c.uv_pipe_t" title="uv_pipe_t"><code class="xref c c-type docutils literal"><span class="pre">uv_pipe_t</span></code></a> handles.
On UNIX platforms, all <a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal"><span class="pre">uv_stream_t</span></code></a> handles are supported.</p>
<p class="last">Also libuv currently makes no ordering guarantee when the blocking mode
is changed after write requests have already been submitted. Therefore it is
recommended to set the blocking mode immediately after opening or creating
the stream.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.4.0: </span>UNIX implementation added.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_stream_get_write_queue_size">
size_t <code class="descname">uv_stream_get_write_queue_size</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_stream_get_write_queue_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>stream-&gt;write_queue_size</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="handle.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal"><span class="pre">uv_handle_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">uv_stream_t</span></code> — Stream handle</a><ul>
<li><a class="reference internal" href="#data-types">Data types</a><ul>
<li><a class="reference internal" href="#public-members">Public members</a></li>
</ul>
</li>
<li><a class="reference internal" href="#api">API</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="process.html"
                        title="previous chapter"><code class="docutils literal"><span class="pre">uv_process_t</span></code> — Process handle</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tcp.html"
                        title="next chapter"><code class="docutils literal"><span class="pre">uv_tcp_t</span></code> — TCP handle</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/stream.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tcp.html" title="uv_tcp_t — TCP handle"
             >next</a> |</li>
        <li class="right" >
          <a href="process.html" title="uv_process_t — Process handle"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">libuv 1.40.1-dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="api.html" >API documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-present, libuv contributors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7.
    </div>
  </body>
</html>